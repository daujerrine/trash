<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Anamitra Ghorui" />
  <title>(DRAFT) Haskell for the Imperative Programmer</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">(DRAFT) Haskell for the Imperative Programmer</h1>
<p class="author">Anamitra Ghorui</p>
</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Contents</h2>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#functions-in-haskell-part-1"><span class="toc-section-number">2</span> Functions in Haskell (Part 1)</a></li>
<li><a href="#control-structures"><span class="toc-section-number">3</span> “Control Structures”</a></li>
<li><a href="#lists-part-1"><span class="toc-section-number">4</span> Lists (Part 1)</a>
<ul>
<li><a href="#head-and-tail"><span class="toc-section-number">4.1</span> <code>head</code> and <code>tail</code></a></li>
<li><a href="#length"><span class="toc-section-number">4.2</span> <code>length</code></a></li>
<li><a href="#take"><span class="toc-section-number">4.3</span> <code>take</code></a></li>
</ul></li>
<li><a href="#where-are-the-loops"><span class="toc-section-number">5</span> Where are the loops?</a></li>
<li><a href="#haskell-is-not-c"><span class="toc-section-number">6</span> Haskell is not C</a></li>
<li><a href="#why-do-this"><span class="toc-section-number">7</span> Why Do This?</a></li>
<li><a href="#few-more-interpreter-facilities"><span class="toc-section-number">8</span> Few More Interpreter Facilities</a>
<ul>
<li><a href="#running-code-from-files"><span class="toc-section-number">8.1</span> Running Code From Files</a></li>
<li><a href="#multiline-statements"><span class="toc-section-number">8.2</span> Multiline Statements</a></li>
<li><a href="#convenience-settings-for-the-interpreter"><span class="toc-section-number">8.3</span> Convenience Settings for the Interpreter</a></li>
</ul></li>
<li><a href="#functions-in-haskell-part-2"><span class="toc-section-number">9</span> Functions in Haskell (Part 2)</a>
<ul>
<li><a href="#operators-are-also-functions"><span class="toc-section-number">9.1</span> Operators are also functions</a></li>
<li><a href="#what-about-operator-precedence"><span class="toc-section-number">9.2</span> What about Operator Precedence?</a></li>
<li><a href="#pattern-matching"><span class="toc-section-number">9.3</span> Pattern Matching</a></li>
<li><a href="#more-ways-to-define-functions"><span class="toc-section-number">9.4</span> More Ways to Define Functions</a>
<ul>
<li><a href="#definitions-using-pattern-matching"><span class="toc-section-number">9.4.1</span> Definitions using Pattern Matching</a></li>
<li><a href="#case-syntax"><span class="toc-section-number">9.4.2</span> <code>case</code> Syntax</a></li>
<li><a href="#guard-syntax"><span class="toc-section-number">9.4.3</span> Guard Syntax</a></li>
<li><a href="#let-..-in-..-syntax"><span class="toc-section-number">9.4.4</span> <code>let .. in ..</code> Syntax</a></li>
<li><a href="#where-syntax"><span class="toc-section-number">9.4.5</span> <code>where</code> Syntax</a></li>
</ul></li>
<li><a href="#currying"><span class="toc-section-number">9.5</span> Currying</a>
<ul>
<li><a href="#currying-infix-operators"><span class="toc-section-number">9.5.1</span> Currying infix operators</a></li>
</ul></li>
<li><a href="#function-composition"><span class="toc-section-number">9.6</span> Function Composition</a></li>
<li><a href="#anonymous-or-lambda-functions"><span class="toc-section-number">9.7</span> Anonymous or Lambda Functions</a></li>
<li><a href="#evaluating-functions-inside-functions"><span class="toc-section-number">9.8</span> Evaluating Functions Inside Functions</a></li>
</ul></li>
<li><a href="#haskells-type-system"><span class="toc-section-number">10</span> Haskell’s Type System</a>
<ul>
<li><a href="#explicit-declation-of-the-type-of-an-identifier"><span class="toc-section-number">10.1</span> Explicit Declation of the Type of an Identifier</a></li>
<li><a href="#defining-function-types"><span class="toc-section-number">10.2</span> 10.2 Defining Function Types</a></li>
<li><a href="#type-variables"><span class="toc-section-number">10.3</span> Type Variables</a></li>
<li><a href="#typeclasses"><span class="toc-section-number">10.4</span> Typeclasses</a></li>
<li><a href="#functions-with-functions-as-arguments-revisited"><span class="toc-section-number">10.5</span> Functions with Functions as Arguments Revisited</a></li>
</ul></li>
<li><a href="#lists-part-2"><span class="toc-section-number">11</span> Lists (Part 2)</a>
<ul>
<li><a href="#lists-in-haskell-are-not-arrays"><span class="toc-section-number">11.1</span> “Lists” in Haskell are not Arrays</a></li>
<li><a href="#cons-in-haskell"><span class="toc-section-number">11.2</span> Cons in Haskell</a></li>
<li><a href="#using-cons-for-pattern-matching"><span class="toc-section-number">11.3</span> Using Cons for Pattern Matching</a></li>
<li><a href="#list-ranges"><span class="toc-section-number">11.4</span> List Ranges</a></li>
<li><a href="#list-comprehensions"><span class="toc-section-number">11.5</span> List Comprehensions</a></li>
</ul></li>
<li><a href="#tuples"><span class="toc-section-number">12</span> Tuples</a>
<ul>
<li><a href="#fst-and-snd"><span class="toc-section-number">12.1</span> <code>fst</code> and <code>snd</code></a></li>
</ul></li>
<li><a href="#iteration-in-haskell"><span class="toc-section-number">13</span> Iteration in Haskell</a>
<ul>
<li><a href="#the-iterate-function"><span class="toc-section-number">13.1</span> The <code>iterate</code> Function</a></li>
<li><a href="#the-map-function"><span class="toc-section-number">13.2</span> The <code>map</code> function</a></li>
<li><a href="#the-filter-function"><span class="toc-section-number">13.3</span> The <code>filter</code> Function</a></li>
<li><a href="#the-function-application-operator"><span class="toc-section-number">13.4</span> The Function Application Operator (<code>$</code>)</a></li>
<li><a href="#the-zip-function"><span class="toc-section-number">13.5</span> The <code>zip</code> Function</a></li>
<li><a href="#the-zipwith-function"><span class="toc-section-number">13.6</span> The <code>zipWith</code> Function</a></li>
<li><a href="#the-fold-and-scan-functions"><span class="toc-section-number">13.7</span> The <code>fold</code> and <code>scan</code> Functions</a>
<ul>
<li><a href="#foldl-fold-from-left-to-right"><span class="toc-section-number">13.7.1</span> <code>foldl</code>: Fold from Left to Right</a></li>
<li><a href="#foldr-fold-from-right-to-left"><span class="toc-section-number">13.7.2</span> <code>foldr</code>, Fold from Right to Left</a></li>
<li><a href="#scanl-and-scanr"><span class="toc-section-number">13.7.3</span> <code>scanl</code> and <code>scanr</code></a></li>
<li><a href="#note-pattern-matching-in-these-functions"><span class="toc-section-number">13.7.4</span> Note: Pattern Matching in these Functions</a></li>
<li><a href="#foldl1-foldr1-scanl1-and-scanr1"><span class="toc-section-number">13.7.5</span> <code>foldl1</code>, <code>foldr1</code>, <code>scanl1</code> and <code>scanr1</code></a></li>
</ul></li>
</ul></li>
<li><a href="#data-records-types-and-typeclasses"><span class="toc-section-number">14</span> Data, Records, Types, and Typeclasses</a>
<ul>
<li><a href="#data"><span class="toc-section-number">14.1</span> Data</a>
<ul>
<li><a href="#printing-new-data-types"><span class="toc-section-number">14.1.1</span> Printing New Data Types</a></li>
<li><a href="#tuple-like-data"><span class="toc-section-number">14.1.2</span> Tuple-Like Data</a></li>
<li><a href="#type-variables-in-data-constructors"><span class="toc-section-number">14.1.3</span> Type Variables in Data Constructors</a></li>
<li><a href="#recursive-data-constructors"><span class="toc-section-number">14.1.4</span> Recursive Data Constructors</a></li>
<li><a href="#records"><span class="toc-section-number">14.1.5</span> Records</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<pre><code></code></pre>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="Creative Commons License" /></a> This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><strong>Contact:</strong></p>
<ul>
<li>Email: <code>anamitraghorui gmail</code></li>
<li>Github: <a href="https://github.com/daujerrine">github.com/daujerrine</a></li>
<li>Website: <a href="https://visphort.net/">visphort.net</a></li>
</ul>
<p>TODO Rename “variable” to “identifier” and “definition” with “binding”</p>
<h1 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p><em>I will assume that you are proificient in at least one C or C-Like language, such as Python, Java, C++, Javascript etc.</em></p>
<p>Haskell is a programming language.</p>
<p>The current de-facto compiler for Haskell is the Glasgow Haskell Compiler (GHC). <a href="https://www.haskell.org/ghc/">You can find it here.</a></p>
<p>You can start an interpreter on a terminal using the <code>ghci</code> command. You will be greeted with a prompt like this:</p>
<pre><code>
$ ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/turpentine/.ghci
Prelude&gt; 
</code></pre>
<p><code>Prelude</code>, here, is a Haskell module. It is loaded by default into the interpreter and contains several core functions. Any new modules you load will appear prefixed against the prompt.</p>
<p>For the purposes of this document, we will not show the prompt as “<code>Prelude&gt;</code>”, but as “<code>&gt;</code>”. See Section 8.3 on how to actually remove it from your interpreter.</p>
<p>Here are a few basic commands. Try typing them in:</p>
<p><span id="example:1.1" class="pandoc-numbering-text example"><strong>Example 1.1</strong></span></p>
<pre><code>Comments:

    &gt; -- You can put comments like this.

&quot;Hello World&quot; Demonstration:
    
    &gt; putStrLn(&quot;Hello&quot;) -- &quot;Put String Line&quot;
    Hello

Variables:
    
    &gt; x = 5
    &gt; x
    5

Operators:
    
    &gt; x = 5
    &gt; x + 5
    10 

Convert things to strings:
    
    &gt; show(5)
    &quot;5&quot;
    &gt; putStrLn(show(5))
    5

Concatenation:

    &gt; putStrLn(&quot;The number is: &quot; ++ show(5))
    The number is: 5</code></pre>
<p>Unless if it is to establish precedence order, parantheses for arguments are not necessary:</p>
<p><span id="example:1.2" class="pandoc-numbering-text example"><strong>Example 1.2</strong></span></p>
<pre><code>    &gt; putStrLn &quot;Hello&quot;
    Hello
    &gt; show 5
    &quot;5&quot;</code></pre>
<p><span id="example:1.3" class="pandoc-numbering-text example"><strong>Example 1.3</strong></span></p>
<pre><code>    &gt; putStrLn &quot;Hello &quot; ++ show 5

    &lt;interactive&gt;:3:1: error:
        • Couldn&#39;t match expected type ‘[Char]’ with actual type ‘IO ()’
        • In the first argument of ‘(++)’, namely ‘putStrLn &quot;Hello&quot;’
          In the expression: putStrLn &quot;Hello&quot; ++ show 5
          In an equation for ‘it’: it = putStrLn &quot;Hello&quot; ++ show 5</code></pre>
<p>The error message says that there are invalid arguments to the operator <code>++</code>, because <code>++</code> sees the following precedence:</p>
<pre><code>(putStrLn &quot;Hello &quot;) ++ (show 5).</code></pre>
<p><span id="example:1.4" class="pandoc-numbering-text example"><strong>Example 1.4</strong></span></p>
<pre><code>    &gt; putStrLn &quot;Hello &quot; ++ (show 5)

    &lt;interactive&gt;:4:1: error:
        • Couldn&#39;t match expected type ‘[Char]’ with actual type ‘IO ()’
        • In the first argument of ‘(++)’, namely ‘putStrLn &quot;Hello&quot;’
          In the expression: putStrLn &quot;Hello&quot; ++ (show 5)
          In an equation for ‘it’: it = putStrLn &quot;Hello&quot; ++ (show 5)</code></pre>
<p>Still invalid arguments to the operator <code>++</code> with the same precedence.</p>
<p><span id="example:1.5" class="pandoc-numbering-text example"><strong>Example 1.5</strong></span></p>
<pre><code>    &gt; putStrLn (&quot;Hello &quot; ++ (show 5))
    Hello 5
</code></pre>
<p>Correct arguments and precedence.</p>
<p><span id="example:1.6" class="pandoc-numbering-text example"><strong>Example 1.6</strong></span></p>
<pre><code>    &gt; putStrLn (&quot;Hello &quot; ++ show 5)
    Hello 5
</code></pre>
<p>Also correct arguments and precedence.</p>
<p>For now, we will ignore the detailed description of the error messages such as the above. The error messages should become intuitive to you once you are familiar with all the features in Haskell.</p>
<h1 data-number="2" id="functions-in-haskell-part-1"><span class="header-section-number">2</span> Functions in Haskell (Part 1)</h1>
<p>In Haskell, <em>basic</em> functions behave as if they were <em>mathematical expressions</em>. That is. Functions simply contain a logical formula. The result of the formula after we substitute any variables present and evaluate the formula is what is returned.</p>
<p><span id="example:2.1" class="pandoc-numbering-text example"><strong>Example 2.1</strong></span></p>
<pre><code>
Mathematical/Natural Language Expression:
    
    Let f(x) = x + 5.
    Hence, f(9) = 14.
    
    Let f(x, y) = x + y + 5.
    Hence, f(9, 1) = 15.
    
Haskell:
    
    &gt; f x = x + 5
    &gt; f 9
    14
    &gt; f x y = x + y + 5
    &gt; f 9 1
    15
    
Equivalent expression in Python:
    &gt;&gt;&gt; f = lambda x: x + 5
    &gt;&gt;&gt; f(9)
    14
    &gt;&gt;&gt; f = lambda x, y: x + y + 5
    &gt;&gt;&gt; f(9, 1)
    15</code></pre>
<p><em>All</em> of these above expressions satisfy the mathematical definition of a function:</p>
<blockquote>
<p>In mathematics, a function is a binary relation between two sets that associates every element of the first set to exactly one element of the second set.</p>
<p>– <a href="https://en.wikipedia.org/wiki/Function_(mathematics)">Function (mathematics). Wikipedia, the Free Encyclopedia</a>. Retrieved 23rd December 2020</p>
</blockquote>
<p>We will refer to these two sets: the one which is the input set, and the output set to which the function <em>maps</em> each value from the input set to, as the <em>Domain</em> and the <em>Codomain</em> respectively.</p>
<pre><code>                         f(x) = x + 5
                            
        Domain                                  Codomain
         ...                                      ...
          1  -----------------------------------&gt;  6
          2  -----------------------------------&gt;  7
          3  -----------------------------------&gt;  8
          4  -----------------------------------&gt;  9
          5  -----------------------------------&gt;  10
         ...                                      ...
</code></pre>
<p>We will get to how functions like <code>putStrLn</code> work later.</p>
<p>TODO: 1. Operators are functions 2. Function declaration methods 3. Type system</p>
<h1 data-number="3" id="control-structures"><span class="header-section-number">3</span> “Control Structures”</h1>
<p>There is only one “control structure” in Haskell: the <code>if</code> statement.</p>
<p><span id="example:3.1" class="pandoc-numbering-text example"><strong>Example 3.1</strong></span></p>
<pre><code>    &gt; x = 5
    &gt; if x == 5 then &quot;great&quot; else &quot;that&#39;s okay too&quot;
    &quot;great&quot;
    &gt; x = 6
    &gt; if x == 5 then &quot;great&quot; else &quot;that&#39;s okay too&quot;
    &quot;that&#39;s okay too&quot;

You may notice that the if statement is returning a string.</code></pre>
<p>You can use these in functions as well:</p>
<p><span id="example:3.2" class="pandoc-numbering-text example"><strong>Example 3.2</strong></span></p>
<pre><code>    &gt; isItGreat x = if x == 5 then &quot;great&quot; else &quot;that&#39;s okay too&quot; 
    &gt; isItGreat 8
    &quot;that&#39;s okay too&quot;
    &gt; putStrLn(isItGreat 8)
    that&#39;s okay too
    &gt; putStrLn(isItGreat 5)
    great
</code></pre>
<p>You can make a nested if-else statement like this by using the <code>else if</code> notation:</p>
<p><span id="example:3.3" class="pandoc-numbering-text example"><strong>Example 3.3</strong></span></p>
<pre><code>    &gt; isItGreat x = if x == 5 then &quot;great&quot; else if x == 7 then &quot;also gre
    at&quot; else &quot;that&#39;s okay too&quot;
    &gt; putStrLn(isItGreat 7)
    also great
</code></pre>
<p>We will get to loops later.</p>
<h1 data-number="4" id="lists-part-1"><span class="header-section-number">4</span> Lists (Part 1)</h1>
<p>You can declare lists in Haskell like this:</p>
<p><span id="example:4.1" class="pandoc-numbering-text example"><strong>Example 4.1</strong></span></p>
<pre><code>    &gt; a = [1, 2, 3, 4]
    &gt; a
    [1,2,3,4]</code></pre>
<p>List Indexing works like this. List indices start from 0.:</p>
<p><span id="example:4.2" class="pandoc-numbering-text example"><strong>Example 4.2</strong></span></p>
<pre><code>    &gt; a !! 1
    &gt; 2</code></pre>
<p>There are a few inbuilt functions that will come in handy later:</p>
<h2 data-number="4.1" id="head-and-tail"><span class="header-section-number">4.1</span> <code>head</code> and <code>tail</code></h2>
<p><span id="example:4.3" class="pandoc-numbering-text example"><strong>Example 4.3</strong></span></p>
<pre><code>(Continuing from the previous example:)

The following function returns the First element, or head of the array:

    &gt; head a
    1

This will return the rest of the array, excluding the array:

    &gt; tail a
    [2,3,4]
    &gt; tail (tail a)
    [3, 4]</code></pre>
<ul>
<li>In the second expression, we use brackets to separate the arguments and establish the order of evaluation. (tail (tail a)) is also a valid and equivalent statement</li>
<li>You may notice that the above two allow us to operate on arrays like linked lists.</li>
</ul>
<p>Let’s tail a few more times:</p>
<pre><code>    &gt; tail (tail (tail (tail a)))
    []</code></pre>
<p>We have reached the end of the list, which was of length 4. Hence ot returns an empty list. Let’s keep this property in mind.</p>
<p>Putting in so many brackets is a bit tiresome. We can abbreviate such expressions using the “$” operator:</p>
<pre><code>    &gt; tail $ tail $ tail $ tail a
    []</code></pre>
<p>The “<code>$</code>” operator says that everything to its right is inside a new layer of parantheses. More accurately, it says that everything to its right is a parameter to the function on the left. This is also called the function application operator and a detailed description of it is given in section 9.</p>
<h2 data-number="4.2" id="length"><span class="header-section-number">4.2</span> <code>length</code></h2>
<p>This one returns the length, as expected:</p>
<p><span id="example:4.4" class="pandoc-numbering-text example"><strong>Example 4.4</strong></span></p>
<pre><code>(Continuing from the previous example:)

    &gt; length a
    4</code></pre>
<h2 data-number="4.3" id="take"><span class="header-section-number">4.3</span> <code>take</code></h2>
<p>You can slice a desired number of elements from the start of a list using <code>take</code>:</p>
<p><span id="example:4.5" class="pandoc-numbering-text example"><strong>Example 4.5</strong></span></p>
<pre><code>    &gt; take 2 [1, 2, 3, 4, 5]
    [1,2]
</code></pre>
<h1 data-number="5" id="where-are-the-loops"><span class="header-section-number">5</span> Where are the loops?</h1>
<p>There are no looping control structures in Haskell. You instead perform most computation using <em>recursive functions</em>.</p>
<p><span id="example:5.1" class="pandoc-numbering-text example"><strong>Example 5.1</strong></span></p>
<pre><code>Summing numbers in a C-Like Language. We simply add numbers to keep
track of the array index here:
    
    int x[] = {1, 2, 3, 4, 5};
    int sum = 0;
    for (int i = 0; i &lt; lengthOf(x); i++) {
        sum += x[i];
    }

Summing numbers in Python. Instead of using a numerical index, we use
an iterator instead (although it is still possible to use a numerical
index here, the intent here is to illustrate the use of iterators
in a conventional language):
    
    x = [1, 2, 3, 4, 5]
    sum = 0
    for i in x:
        sum += i

Now, Summing numbers in Haskell:
    
    &gt; sumNumbers x = if x == [] then 0
         else head x + sum (tail x)
    &gt; sumNumbers [1, 2, 3, 4]
    10</code></pre>
<p>This is an implementation of a recursive function. Let’s see what’s happening here:</p>
<pre><code>    if x == [] then 0</code></pre>
<p>We had previously seen that if we reach the end of a list, the tail tail function returns an empty list (since the end of the list is tailed by nothing). Hence, we say that once we reach the end of the list, we check whether x is an empty list or not. If it is, We say that the sum of the list is 0, which is true. This is our <em>Base Case</em> for the recursion.</p>
<pre><code>    else head x + sum (tail x)</code></pre>
<p>Else, we say that the sum is the first item of the list, plus the sum of the rest of the list.</p>
<p>If we were to write this in a C-Like Language, it would look like this:</p>
<pre><code>    int sumNumbers(int x[]) {
        if (isEmpty(x)) {
            return 0;
        } else {
            return x[0] + sumNumbers(tail(x));
        }
    }</code></pre>
<p>Such a function would otherwise cause a Stack Overflow with very large input in other languages. However, this does not happen in Haskell.</p>
<h1 data-number="6" id="haskell-is-not-c"><span class="header-section-number">6</span> Haskell is not C</h1>
<p>By now it might be obvious to you that this is something radically different, way different than what you might have expected if you have never previously heard about <em>Functional Programming Languages</em> of which haskell is one.</p>
<p>Languages such as C, C++, Java, Python all are called <em>Imperative Languages</em>. Here, we clearly specify the steps to follow in a specified order, which change the program’s <em>current state</em> (such as, by changing the value of a variable) to achieve a solution. In short, <em>time matters most of the time</em>.</p>
<p>Functional Programming languages, however, come under <em>Declarative Programming Languages</em>. In declarative languages, we ask for a solution, but <em>not</em> how to achieve that solution. SQL and Make Files are examples of Declarative Programming languages which are <em>not</em> Functional Programming Languages.</p>
<p>In Functional Programming languages, we compose our programs using functions, however, there is little to no explicit definition of the order in which statements shall execute. We also avoid changing values of variables with respect to time as much as possible, that is, changing or <em>mutating</em> the state. Hence,</p>
<p><em>We attempt to minimise how much time matters.</em></p>
<p>Haskell comes under the class of <a href="https://en.wikipedia.org/wiki/Purely_functional_programming"><em>Pure</em> functional programming languages</a>.</p>
<p>Recursion is used as a tool to define an <em>implicit order</em> in the solutions to our problems. <strong>Haskell is built around efficient execution of such recursive functions and is the main method to solve problems in it</strong>.</p>
<p>Have a look at Example 5.1 again and compare the Non-Haskell versions to the Haskell ones, and see: 1. How many variables are used in the program. 2. How many times a variable is mutated by the program in both versions. 3. How and how many times that the mutation is percievable with respect to the current scope.</p>
<h1 data-number="7" id="why-do-this"><span class="header-section-number">7</span> Why Do This?</h1>
<p>While a proper introduction of haskell’s features have not yet been given, here are some of the advantages of having no mutation of state and no explicit execution order:</p>
<ol type="1">
<li><p><strong>Allow you to focus of the algorithm instead of its underlying implementation:</strong> In languages like C, you have to implement algorithms such as binary search by explicitly defining certain variables in order to keep track of the sub array, and change their state in each step to find the solution. Thus you have to modify the original algorithm quite a bit to get an efficient, practical program. In Haskell, however, you merely focus on the theoretical solution and you leave it to the compiler to convert it into an effecient program in most cases.</p></li>
<li><p><strong>Allow you to write better concurrent programs:</strong> The fact that there is no mutation of state in functional programming means that all values in a concurrent variable will be fixed. Usually we instead implement an event-based message queue, where a concurrent process waits for a value on the queue, and continues only when a value is obtained. TODO</p></li>
<li><p><strong>Allow you to use constructs from discrete mathematics:</strong> There are a lot of parallels between discrete mathematics and constructs present in Haskell, and allow you to use those structures in that manner.</p></li>
<li><p><strong>Reduce the general complexity of a program:</strong> This is in part due to all of the above mentioned statements.</p></li>
</ol>
<h1 data-number="8" id="few-more-interpreter-facilities"><span class="header-section-number">8</span> Few More Interpreter Facilities</h1>
<h2 data-number="8.1" id="running-code-from-files"><span class="header-section-number">8.1</span> Running Code From Files</h2>
<p>You can type all of the above examples into a file and run them in the interpreter. Try creating a file with the following code:</p>
<pre><code>    formula a b = (a * b) / (a + b)
</code></pre>
<p>And saving it with a filename, say, <code>code.hs</code>. (Haskell sourcecode uses the <code>.hs</code> extension.)</p>
<p>Now, open a terminal and supply the file to the interpreter. You will be greeted with the following:</p>
<pre><code>    $ ghci formula.hs
    GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
    Loaded GHCi configuration from /home/turpentine/.ghci
    [1 of 1] Compiling Main             ( a.hs, interpreted )
    Ok, one module loaded.
    &gt;</code></pre>
<p>Your file now has been loaded as a module, with its identifiers now in the interpreter’s namespace.</p>
<p>Now try using the function:</p>
<pre><code>    &gt; formula 2 3
    1.2</code></pre>
<p>We will eventually discuss <em>Compiled Haskell</em>. However, it will come in a later section and for now this will be enough to execute the examples present in the following sections.</p>
<h2 data-number="8.2" id="multiline-statements"><span class="header-section-number">8.2</span> Multiline Statements</h2>
<p>The examples following this section will require you to enter in multiline statements. You can start a multiline statement by typing in <code>:{</code>, and ending with <code>:}</code> in the interpreter:</p>
<pre><code>    &gt; :{
    .. a x y = 
    ..     if x &gt; y then 1
    ..     else 0
    .. :}
    &gt; a 2 3
    0</code></pre>
<p>The above expression can be also written without the <code>:{</code> and <code>:}</code> commands if executed from a file. In that case, it would appear like this:</p>
<pre><code>a x y = 
    if x &gt; y then 1
    else 0</code></pre>
<p>Whitespace matters in Haskell, and indentation denotes a program block.</p>
<h2 data-number="8.3" id="convenience-settings-for-the-interpreter"><span class="header-section-number">8.3</span> Convenience Settings for the Interpreter</h2>
<p>You can specify certain options in the interpreter. All of these options are prefixed with a colon (<code>:</code>), like the <code>:{</code> and <code>:}</code> mentioned before.</p>
<p>Here are a few that will make it a bit easier to use the interpreter</p>
<ul>
<li><p><code>:set +m</code>: Set multiline mode. If Haskell detects that a statement will require multiple lines to complete, Haskell wil automatically enter the multiline mode. This does not work in all cases, as you will see in the following sections.</p></li>
<li><p><code>:set prompt "&gt; "</code>: This will change your prompt from <code>Prelude&gt;</code> to <code>&gt;</code>.</p></li>
<li><p><code>:set prompt-cont “..”</code>: This will change the multiline block prompt from <code>Prelude|</code> to <code>.. </code></p></li>
</ul>
<p>You can make it so that all of these options are enabled in startup by typing these in to GHCI’s startup script. Depending on your system, this file may be named <code>.ghci</code> or <code>ghci.conf</code>. Their locations cab be found <a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/ghci.html#the-ghci-files">here</a>.</p>
<h1 data-number="9" id="functions-in-haskell-part-2"><span class="header-section-number">9</span> Functions in Haskell (Part 2)</h1>
<h2 data-number="9.1" id="operators-are-also-functions"><span class="header-section-number">9.1</span> Operators are also functions</h2>
<p>All functions that have these following characters <a href="https://www.haskell.org/onlinereport/lexemes.html">[1]</a> allow you to supply 2 arguments to the function in <em>infix</em> order:</p>
<pre><code> ! # $ % &amp; * + . / &lt; = &gt; ? @ \ ^ | - ~</code></pre>
<p>Here’s an example:</p>
<p><span id="example:9.1" class="pandoc-numbering-text example"><strong>Example 9.1</strong></span></p>
<pre><code>Let&#39;s make an operator that finds the hypotenuse of a right angled
triangle:

    &gt; a %% b = sqrt (a ^ 2 + b ^ 2)
    &gt; 3 %% 4
    5.0

&quot;sqrt&quot;, here, is a library function and already available to you.</code></pre>
<p>We can use an operator in prefix operator by simply adding parantheses to the token:</p>
<p><span id="example:9.2" class="pandoc-numbering-text example"><strong>Example 9.2</strong></span></p>
<pre><code>    &gt; (%%) 3 4
    5.0</code></pre>
<p>You can also define operators in this prefix manner:</p>
<p><span id="example:9.3" class="pandoc-numbering-text example"><strong>Example 9.3</strong></span></p>
<pre><code>    &gt; (%%) a b = sqrt (a ^ 2 + b ^ 2)
    &gt; 3 %% 4
    5.0
</code></pre>
<p>TODO acknowledge this is simply pattern matching</p>
<p>You can add as many characters as you want to the operator:</p>
<p><span id="example:9.4" class="pandoc-numbering-text example"><strong>Example 9.4</strong></span></p>
<pre><code>    &gt; (%%%%%%%%%%%%%%) a b = sqrt (a ^ 2 + b ^ 2)
    &gt; 3 %%%%%%%%%%%%%% 4
    5.0</code></pre>
<p>Conversely, we can turn any other function into a prefix operator by enclosing its token in tildes (<code>`</code>):</p>
<p><span id="example:9.5" class="pandoc-numbering-text example"><strong>Example 9.5</strong></span></p>
<pre><code>    &gt; hypotenuse a b = sqrt (a ^ 2 + b ^ 2)
    &gt; 3 `hypotenuse` 4
    5.0</code></pre>
<h2 data-number="9.2" id="what-about-operator-precedence"><span class="header-section-number">9.2</span> What about Operator Precedence?</h2>
<p>There are certain operator/function tokens that are given a <a href="https://www.haskell.org/onlinereport/decls.html#fixity">predefined precedence</a> by Haskell. These include operations like <code>+, -, *, /, `mod`</code> etc. Other than this, since there are no differences between operators and functions aside from operators being in infix order by default, custom operators have the same precedence as normal functions.</p>
<h2 data-number="9.3" id="pattern-matching"><span class="header-section-number">9.3</span> Pattern Matching</h2>
<p>Each function definition in Haskell is a “pattern”. Definition of a function with arguments makes you define a pattern. Haskell will look for these series of tokens and arguments with appropriate type and <em><a href="https://en.wikipedia.org/wiki/Greedy_algorithm">greedily</a></em> match the pattern specified by the function. By “Greedy,” we mean that it will look for the earliest, and closest match while performing the pattern matching. Mirroring the short-sighted nature of most greedy people looking for immediate satiation.</p>
<p>We utilise this concept in Haskell to match about any pattern consisting of any expression, and not just restricted to simple variables. We can even use constants in patterns. We will discuss this in the next section.</p>
<p>TODO Phrase this better maybe.</p>
<p><span id="example:9.6" class="pandoc-numbering-text example"><strong>Example 9.6</strong></span></p>
<pre><code>Matching a list of 2 elements:
    &gt; f [a, b] = a + b
    &gt; f [2, 3]
    5
    
Matching a list of 2 elements and another variable:
    &gt; f [a, b] c = a + b + c
    &gt; f [1, 2] 3
    6</code></pre>
<h2 data-number="9.4" id="more-ways-to-define-functions"><span class="header-section-number">9.4</span> More Ways to Define Functions</h2>
<h3 data-number="9.4.1" id="definitions-using-pattern-matching"><span class="header-section-number">9.4.1</span> Definitions using Pattern Matching</h3>
<p>Aside from using the <code>if</code> block, we can also use pattern matching to define a function, and what should the function return at a particular value. This allows for a more natural-language or mathematical language manner of defining a function:</p>
<p><span id="example:9.7" class="pandoc-numbering-text example"><strong>Example 9.7</strong></span></p>
<pre><code>Mathematical definition of the factorial function:
    Factorial(0) = 1
    Factorial(1) = 1
    Factorial(N) = N * Factorial(N - 1)
    
The factorial function in Haskell using pattern matching:

    &gt; :{
    .. fac 0 = 1
    .. fac 1 = 1
    .. fac n = n * fac (n - 1)
    .. :}
    &gt; fac 5
    120

Factorial in a C-like Language:

int fac(int n) {
    if (n == 0)
        return 1;
    else if (n == 1)
        return 1;
    else
        return n * fac(n - 1)
}
</code></pre>
<p><em>Note the use of <code>:{</code> and <code>:}</code> commands over here. These define a multiline block and is required for defining such a function written in multiple lines. Otherwise, the function definition is always overwritten each time we attempt to add a new pattern. This problem is avoided when executing from a file instead.</em></p>
<p>Unlike in conventional imperative languages, it completely avoids using an <code>if-else</code> block.</p>
<p>A more complex example is as follows:</p>
<p><span id="example:9.8" class="pandoc-numbering-text example"><strong>Example 9.8</strong></span></p>
<pre><code>Pattern with a 2 element list, and matching a list that has the second
element as 1:

    &gt; :{
    .. f [a, 1] = a + 999
    .. f [a, b] = a + b
    .. :}
    &gt; f [1000, 1]
    1999
    &gt; f [1000, 2]
    1002

Pattern with a 2 element list and a variable:

    &gt; :{
    .. f [a, 1] 1 = a + 999 + 111
    .. f [a, b] c = a + b + c
    .. :}
    &gt; f [1000, 1] 1
    2110
    &gt; f [1, 2] 3
    6</code></pre>
<h3 data-number="9.4.2" id="case-syntax"><span class="header-section-number">9.4.2</span> <code>case</code> Syntax</h3>
<p>The <code>case</code> syntax allows you to match a given expression against a set of patterns:</p>
<p><span id="example:9.9" class="pandoc-numbering-text example"><strong>Example 9.9</strong></span></p>
<pre><code>On a single line:

    &gt; x = 5
    &gt; case x of 5 -&gt; 7; 7 -&gt; 9; 9 -&gt; 11
    7

In multiline mode:

    &gt; x = 5
    &gt; case x of
    ..     5 -&gt; 7
    ..     7 -&gt; 9
    ..     9 -&gt; 11
    .. 
    7</code></pre>
<p><em>Note how we no longer use <code>:{</code>, <code>:}</code> for a mutiline statement. this is due to the <code>:set +m</code> option mentioned in Section 8.3.</em></p>
<p>You can use this syntax to perform pattern matching in a function:</p>
<p><span id="example:9.10" class="pandoc-numbering-text example"><strong>Example 9.10</strong></span></p>
<pre><code>    &gt; fac n = case n of
    ..     0 -&gt; 1;
    ..     1 -&gt; 1;
    ..     otherwise -&gt; n * fac (n - 1);
    .. 
    &gt; fac 5
    120</code></pre>
<p>Note the use of the <code>otherwise</code> keyword over here. <code>otherwise</code> contains the default case that will match any case that has not been already specified in the case block.</p>
<p>Case blocks are simply syntactic sugar and analogous to normal function pattern matching. Hence, we can rewrite the first definition in Example 9.3 as follows:</p>
<p><span id="example:9.11" class="pandoc-numbering-text example"><strong>Example 9.11</strong></span></p>
<pre><code>    &gt; f x = case x of
    ..     [a, 1] -&gt; a + 999
    ..     [a, b] -&gt; a + b
    .. </code></pre>
<p>Notice how we have utilised <code>a</code>, <code>b</code> as placeholder variables here.</p>
<h3 data-number="9.4.3" id="guard-syntax"><span class="header-section-number">9.4.3</span> Guard Syntax</h3>
<p>Guard syntax allows you to define a function by checking against a set of conditions rather than equating patterns. This is a shorter method to write <code>if-else</code> statements present in imperative languages.</p>
<p>Within an interpreter you will have to use an explicit multiline block to define the function on multiple lines, unlike the previous one. Each conditional block is prefixed with an ‘<code>|</code>’</p>
<p><span id="example:9.12" class="pandoc-numbering-text example"><strong>Example 9.12</strong></span></p>
<pre><code>This function finds the max of two numbers:

    &gt; :{
    .. f a b
    ..     | a &gt; b = a
    ..     | otherwise = b
    .. 
    .. :}
    &gt; f 2 3
    3</code></pre>
<p>You can also write the function in one line, albeit being less readable:</p>
<p><span id="example:9.13" class="pandoc-numbering-text example"><strong>Example 9.13</strong></span></p>
<pre><code>    &gt; f a b | a &gt; b = a | otherwise = b
    &gt; f 3 2
    3</code></pre>
<p>The <code>otherwise</code> keyword here was used in the same manner as in the previous case block method.</p>
<p>A more complex example is as follows:</p>
<p><span id="example:9.14" class="pandoc-numbering-text example"><strong>Example 9.14</strong></span></p>
<pre><code>This is a 3 way comparator. It returns greater than, less than or equal
to depending on the two numbers. This is the &quot;spaceship&quot; operator you
may find in many languages like PHP and C++:
    
    &gt; :{
    .. a &lt;=&gt; b
    ..     | a &gt; b = GT
    ..     | a == b = EQ
    ..     | a &lt; b  = LT
    .. 
    .. :}
    &gt; 2 &lt;=&gt; 2
    EQ
    &gt; 2 &lt;=&gt; 3
    LT
    &gt; 4 &lt;=&gt; 3
    GT
</code></pre>
<p><code>GT</code>, <code>EQ</code>, <code>LT</code> are predefined symbols. We will look into how to define our own such symbols later.</p>
<h3 data-number="9.4.4" id="let-..-in-..-syntax"><span class="header-section-number">9.4.4</span> <code>let .. in ..</code> Syntax</h3>
<p><code>let</code> syntax allows you to define a set of local variables in a block, and use those variables in the final expression of the function.</p>
<p><span id="example:9.15" class="pandoc-numbering-text example"><strong>Example 9.15</strong></span></p>
<pre><code>Inline method:

    &gt; hypotenuse x y = let sqrx = x^2; sqry = y^2; in sqrt (sqrx + sqry)
    &gt; hypotenuse 3 4
    5.0

Non-Inline method:

    &gt; :{
    .. hypotenuse x y = let
    ..     sqrx = x ^ 2
    ..     sqry = y ^ 2
    ..     in sqrt (sqrx + sqry)
    .. :}
    &gt; hypotenuse 3 4
    5.0</code></pre>
<h3 data-number="9.4.5" id="where-syntax"><span class="header-section-number">9.4.5</span> <code>where</code> Syntax</h3>
<p><code>where</code> is similar to <code>let</code>, but in this case we supply local variables after they are defined.</p>
<p><span id="example:9.16" class="pandoc-numbering-text example"><strong>Example 9.16</strong></span></p>
<pre><code>Inline method:

&gt; a = x + y where x = 4; y = 3;
.. 
&gt; a
7

Non-Inline method:

&gt; :{
.. a = x + y
..     where x = 4
..           y = 3
.. :}
&gt; a
7
</code></pre>
<p>It can be used alongwith guards and other statements as well:</p>
<p><span id="example:9.17" class="pandoc-numbering-text example"><strong>Example 9.17</strong></span></p>
<pre><code>This is the 3 way comparator but we replace the numbers with their
negative counterparts:

&gt; :{
.. a &lt;=&gt; b
..     | p &gt; q = GT
..     | p &lt; q = LT
..     | p == q = EQ
..     where p = -a
..           q = -b
.. :}
&gt; 2 &lt;=&gt; 3
GT
&gt; 3 &lt;=&gt; 2
LT
</code></pre>
<h2 data-number="9.5" id="currying"><span class="header-section-number">9.5</span> Currying</h2>
<p>In Haskell, a function with multiple arguments can be turned into another function by supplying a partial number of arguments to it. This is called <a href="https://en.wikipedia.org/wiki/Currying">Currying</a>. If the original function had <code>n</code> arguments, and we have supplied <code>k</code> arguments starting from the left of the argument list, then the new function will have <code>n - k</code> arguments.</p>
<p>For example, we have a function with 2 arguments over here and we supply one of them. In this case below, the parameter <code>x</code> of the function has been bound and a new function is made, with a single parameter <code>y</code>. This is then bound to a new identifier named <code>g</code>:</p>
<p><span id="example:9.18" class="pandoc-numbering-text example"><strong>Example 9.18</strong></span></p>
<pre><code>    &gt; f x y = x + y
    &gt; g = f 2
    &gt; g 3
    5</code></pre>
<p>Here is a far larger example:</p>
<p><span id="example:9.19" class="pandoc-numbering-text example"><strong>Example 9.19</strong></span></p>
<pre><code>    &gt; f u v w x y z = u + v + w + x + y + z
    &gt; g = f 1
    &gt; h = g 2
    &gt; i = h 3
    &gt; j = i 4
    &gt; k = l 5
    &gt; k = j 5
    &gt; l = k 6
    &gt; l
    21
    
    &gt; m = f 1 2 3 4 5
    &gt; m 6
    21</code></pre>
<p>This is useful for, let’s say, creating a function to divide all the elements in a list without having to create an explicit function to do so. We will look into how to do this later.</p>
<h3 data-number="9.5.1" id="currying-infix-operators"><span class="header-section-number">9.5.1</span> Currying infix operators</h3>
<p>We can curry operators in an additional way to the prefix method by enclosing them in brackets and providing an operand on either side of the operator.</p>
<p><span id="example:9.20" class="pandoc-numbering-text example"><strong>Example 9.20</strong></span></p>
<pre><code>    &gt; divideFour = (/4)
    &gt; fourDivide = (4/)
    &gt; divideFour 10
    2.5
    &gt; fourDivide 10
    0.4
</code></pre>
<p><em>Note: You may try currying the “-” operator, but keep in mind that unary “-” is also a separate operator and you will have to adjust for that while currying for the right hand side</em></p>
<h2 data-number="9.6" id="function-composition"><span class="header-section-number">9.6</span> Function Composition</h2>
<p>Function composition in Haskell is exactly the same as mathematical function composion. If there are 2 functions, <code>f(x)</code> and <code>g(x)</code>, then the composed function <code>k(x) = f(x) . g(x)</code> is equivalent to <code>f(g(x))</code>.</p>
<p>The syntax uses the <code>.</code> operator and is used as follows:</p>
<p><span id="example:9.21" class="pandoc-numbering-text example"><strong>Example 9.21</strong></span></p>
<pre><code>    &gt; f x = x - 3
    &gt; g x = 3 - x
    &gt; k = f . g
    &gt; k 0
    0
    &gt; k = g . f
    &gt; k 0
    6</code></pre>
<p>This is useful for chaining the functionalities of multiple functions together.</p>
<h2 data-number="9.7" id="anonymous-or-lambda-functions"><span class="header-section-number">9.7</span> Anonymous or Lambda Functions</h2>
<p><a href="https://en.wikipedia.org/wiki/Anonymous_function">Anonymous functions</a> are functions without an explicit identifier. These are also found in languages like Python, Javascript and recent iterations of C++. These are primarily a functional programming construct.</p>
<p>Anonymous functions start with a backslash (<code>\</code>). It is followed by arguments and finally an arrow (<code>-&gt;</code>), after which the function defintion is written.</p>
<p>Here is an example usage of the syntax:</p>
<p><span id="example:9.22" class="pandoc-numbering-text example"><strong>Example 9.22</strong></span></p>
<pre><code>    &gt; a = \x y z -&gt; x + y + z
    &gt; a 1 2 3
    6</code></pre>
<p>Anonymous functions come in quite handy while designing programs, especially in iteration. We will see its usage in later chapters.</p>
<p>The type definition of the lambda function is inferred from context.</p>
<h2 data-number="9.8" id="evaluating-functions-inside-functions"><span class="header-section-number">9.8</span> Evaluating Functions Inside Functions</h2>
<p>We can use functions inside functions since we can pass functions around as simple variables. Here is a function that takes a function as an argument, evaluates it expecting a number and adds one to it:</p>
<p><span id="example:9.23" class="pandoc-numbering-text example"><strong>Example 9.23</strong></span></p>
<pre><code>    &gt; evalAddOne func num = (func num) + 1
    &gt; evalAddOne (2*) 4
    9</code></pre>
<p>The function decomposes as follows:</p>
<pre><code>    1. evalAddOne (2*) 4
    2. ((2*) 4) + 1
    3. 8 + 1
    4. 9</code></pre>
<h1 data-number="10" id="haskells-type-system"><span class="header-section-number">10</span> Haskell’s Type System</h1>
<p>Haskell is a <a href="https://en.wikipedia.org/wiki/Type_system#STATIC">statically-typed</a> language. Types are determined right when a variable is compiled and retains that type for the rest of its runtime. This ensures that all type errors that will ever occur are detected at compile time.</p>
<p>GHCI is actually an <em>incremental bytecode compiler</em> as opposed to an actual interpreter. Thus whenever you declare a function, type checking is done as soon as you pass the definition to the interpreter, and any errors present are returned to you.</p>
<p>This is in contrast to what happens in a dynamically typed language such as Python. Functions forwarded to the interpreter are only checked for syntax errors, and then <em>type checking is deferred until the function is actually called</em>.</p>
<p>The following example illustrates this difference:</p>
<p><span id="example:10.1" class="pandoc-numbering-text example"><strong>Example 10.1</strong></span></p>
<pre><code>Python Code:
    
    &gt;&gt;&gt; def half_add_str(x):
    ...     return x / 2 + &quot;a&quot;;
    ... 
    &gt;&gt;&gt; half_add_str(3)
    Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
      File &quot;&lt;stdin&gt;&quot;, line 2, in half_add_str
    TypeError: unsupported operand type(s) for +: &#39;float&#39; and &#39;str&#39;


Haskell Code:

    &gt; halfAddStr x = x / 2 + &quot;a&quot;

    &lt;interactive&gt;:8:16: error:
        • No instance for (Fractional [Char]) arising from a use of ‘/’
        • In the first argument of ‘(+)’, namely ‘x / 2’
          In the expression: x / 2 + &quot;a&quot;
          In an equation for ‘halfAddStr’: halfAddStr x = x / 2 + &quot;a&quot;

    &lt;interactive&gt;:8:16: error:
        • No instance for (Num [Char]) arising from a use of ‘+’
        • In the expression: x / 2 + &quot;a&quot;
          In an equation for ‘halfAddStr’: halfAddStr x = x / 2 + &quot;a&quot;
</code></pre>
<p>Note how the Haskell interpreter immediately notices the type error and in the Python interpreter the type checking only happens when we call the function.</p>
<p>Up till now, we have not once explicitly define the type of a given identifier and were depending upon Haskells inferred types to assign a type to the identifier. Now we will learn how to define the type of an identifier and how does the type syntax work in Haskell.</p>
<h2 data-number="10.1" id="explicit-declation-of-the-type-of-an-identifier"><span class="header-section-number">10.1</span> Explicit Declation of the Type of an Identifier</h2>
<p>All explicit type assignments are done using the <code>::</code> operator. Definition of the identifier must also be done on the same block as the type definition.</p>
<p><span id="example:10.2" class="pandoc-numbering-text example"><strong>Example 10.2</strong></span></p>
<pre><code>Defintion on the same line:

    &gt; val :: Int; val = 5
    &gt; val
    5

Definition in a block:

    &gt; :{
    .. val :: Int
    .. val = 5
    .. :}
    &gt; val
    5</code></pre>
<p>“<code>Int</code>”, here, is the integer type. For a full list of standard types, see <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch6.html">here</a>.</p>
<p>The example below illustrates how types are being enforced when we attempt to assign a floating point number to an integer:</p>
<p><span id="example:10.3" class="pandoc-numbering-text example"><strong>Example 10.3</strong></span></p>
<pre><code>    &gt; :{
    .. val :: Int
    .. val = 5.123
    .. :}

    &lt;interactive&gt;:18:7: error:
        • No instance for (Fractional Int) arising from the literal ‘5.123’
        • In the expression: 5.123
          In an equation for ‘val’: val = 5.123</code></pre>
<p>In the interpreter, you can check the type of an identifier by using the <code>:t</code> command.</p>
<pre><code>    &gt; :t val
    val :: Int</code></pre>
<h2 data-number="10.2" id="defining-function-types"><span class="header-section-number">10.2</span> 10.2 Defining Function Types</h2>
<p>Identifier types are represented with syntax that resembles linked lists. These links are represented by arrows (<code>-&gt;</code>). Each element that is not the tail of the list represents an argument to a function, and the tail of the list represnents the final value the identifier will take on after all arguments are supplied, or in other words, the list is traversed.</p>
<p>Let us have a look at a function that takes 2 integers, and finally returns (or more accurately, transforms into) an integer variable:</p>
<p><span id="example:10.4" class="pandoc-numbering-text example"><strong>Example 10.4</strong></span></p>
<pre><code>Defining the function:

    &gt; :{
    .. addTwo :: Int -&gt; Int -&gt; Int
    .. addTwo a b = a + b
    .. :}

Seeing the type using the &#39;:t&#39; command:

    &gt; :t addTwo
    addTwo :: Int -&gt; Int -&gt; Int
    
Using currying to get an intermediate function:

    &gt; intermediateFunction = addTwo 3

Seeing the type. Note how we have &quot;gone&quot; to the next element of the
&quot;linked list&quot;:

    &gt; :t intermediateFunction
    intermediateFunction :: Int -&gt; Int

Evaluating the intermeduate function:

    &gt; finalValue = intermediateFunction 4
    
Seeing the final type. We have now &quot;traversed&quot; another element and have
reached the tail of the list. We now see the type of this final
identifier, which is &quot;Int&quot;.

    &gt; :t finalValue
    finalValue :: Int
    &gt; finalValue
    7</code></pre>
<p>We can also define list types by enclosing the type that the list will bear within square brackets (<code>[]</code>):</p>
<p><span id="example:10.5" class="pandoc-numbering-text example"><strong>Example 10.5</strong></span></p>
<pre><code>    &gt; makeDoubleList :: Int -&gt; [Int]; makeDoubleList k = [k, k * 2] 
    &gt; makeDoubleList 2
    [2,4]</code></pre>
<h2 data-number="10.3" id="type-variables"><span class="header-section-number">10.3</span> Type Variables</h2>
<p>We can use placeholder variables to describe a pattern which can be asigned as a type. A common example of this would be the type definitions of <code>head</code> and <code>tail</code> described previously:</p>
<pre><code>    &gt; :t head
    head :: [a] -&gt; a
    &gt; :t tail
    tail :: [a] -&gt; [a]

&quot;a&quot; is the type variable here. It can be anything.</code></pre>
<p>As you may infer, we know that since the function <code>head</code> will return what is present at the front of the list: 1. It will take a list with some element type <code>a</code> (hence the <em>list</em> type <code>[a]</code>), and then, 2. it will return a variable that has the type of the list element, which is <code>a</code>.</p>
<p>Similarly for <code>tail</code>, it takes in an array and returns an array of the same type. As expected.</p>
<p>Here is an example where we define such a function:</p>
<p><span id="example:10.6" class="pandoc-numbering-text example"><strong>Example 10.6</strong></span></p>
<pre><code>    &gt; doubleList :: a -&gt; [a]; doubleList a = [a, a]
    &gt; doubleList 3
    [3,3]
</code></pre>
<p>These therefore allow us to generically refer to types.</p>
<h2 data-number="10.4" id="typeclasses"><span class="header-section-number">10.4</span> Typeclasses</h2>
<p>Let us try to devise a function that doubles a number by specifying an explicit type:</p>
<p><span id="example:10.7" class="pandoc-numbering-text example"><strong>Example 10.7</strong></span></p>
<pre><code>This function will take an integer and &quot;turn into&quot; an integer, as
inferrable from the type declaration:

    &gt; doubleNumber :: Int -&gt; Int; doubleNumber a = a * 2
    &gt; doubleNumber 2
    4</code></pre>
<p>Let us now attempt to put a floating point argument into <code>doubleNumber</code> now:</p>
<p><span id="example:10.8" class="pandoc-numbering-text example"><strong>Example 10.8</strong></span></p>
<pre><code>    &gt; doubleNumber 2.2

    &lt;interactive&gt;:31:14: error:
        • No instance for (Fractional Int) arising from the literal ‘2.2’
        • In the first argument of ‘doubleNumber’, namely ‘2.2’
          In the expression: doubleNumber 2.2
          In an equation for ‘it’: it = doubleNumber 2.2
</code></pre>
<p>As you can see, the function throws an error since we provide a floating point argument. What if we want our function to be usable with any numerical type available?</p>
<p>Let’s see how conventional languages solve this problem:</p>
<ol type="1">
<li><p><strong>Procedural languages (mainly C)</strong>:</p>
<ul>
<li><p>Procedural languages, such as C may provide a <em>preprocessor system</em> where the preprocessor shall simply copy paste a macro with the required functionality before compilation takes place. These can also be used to make rudimentary templating systems.</p></li>
<li><p>Otherwise, if the system permits pointers, pointers to void may be allowed which would allow access to any sort of data irrespective of its type. A function can thus take a pointer to the data and another parameter for the size of the data, and operate on it as it wishes. However such a method does not detail how the data has been actually stored, so operations on the data block containing a floating point variable as an integer will not work since they are stored differently. The function may then take a parameter for deducing the type of the data block.</p></li>
<li><p>Otherwise, we need to explicitly define separate functions for each type. No other way around it.</p></li>
</ul></li>
<li><p><strong>Statically typed object-oriented languages</strong>:</p>
<ul>
<li><p>Languages such as Java and C++ can utilise <em>function polymorphism</em> to be able to operate multiple types together. However we have to explicitly define a new polymorphic function for each new type that is not necessarily a subclass or we require more functionality for a given subclass.</p></li>
<li><p>Java and C++ provide actual <em>templating systems</em>, where you can use placeholder types and variables. The internal system generates multiple instances of the same function with different types whenever they are called with such different types.</p></li>
</ul></li>
<li><p><strong>Dynamically typed object-oriented languages</strong>:</p>
<p>Languages such as Python do not perform any type checking at all up until an operation is actually evaluated. Thus no errors are raised during definition of the operation. If bindings to an operator actually exist for all the operands with the given type, the operation succeeds, and if not an error is thrown.</p>
<p>This may become a problem once we attempt to debug code for type errors and mismatches.</p></li>
</ol>
<p>Haskell solves this problem by introducing polymorphism based on <strong>Typeclasses</strong>.</p>
<p>Typeclasses are, as the name suggests: classes of types. These are similar to <em>Interfaces</em> that you will find in C++ or Java.</p>
<p>A typeclass may include one or more <em>type instances</em>, and one or more generic member variables that the instances implement. For example, the <code>Num</code> typeclass includes the following types. These have been probed using GHCI’s <code>:i</code> command:</p>
<pre><code>    &gt; :i Num
    class Num a where
      (+) :: a -&gt; a -&gt; a
      (-) :: a -&gt; a -&gt; a
      (*) :: a -&gt; a -&gt; a
      negate :: a -&gt; a
      abs :: a -&gt; a
      signum :: a -&gt; a
      fromInteger :: Integer -&gt; a
      {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
        -- Defined in ‘GHC.Num’
    instance Num Word -- Defined in ‘GHC.Num’
    instance Num Integer -- Defined in ‘GHC.Num’
    instance Num Int -- Defined in ‘GHC.Num’
    instance Num Float -- Defined in ‘GHC.Float’
    instance Num Double -- Defined in ‘GHC.Float’</code></pre>
<p>The typeclass contains functions/operators like <code>(+)</code>, <code>(-)</code>, <code>abs</code> etc. which each instance type has implemented.</p>
<p>Any instance type of this typeclass <code>Num</code> can be used with any other instance type in the typeclass, provided that they interact only with functions that will maintain the type definition.</p>
<p>We will now rewrite Example 10.7 to allow interoperability with all the instance types:</p>
<p><span id="example:10.9" class="pandoc-numbering-text example"><strong>Example 10.9</strong></span></p>
<pre><code>    &gt; doubleNumber :: Num a =&gt; a -&gt; a; doubleNumber a = a * 2 
    &gt; doubleNumber 4
    8
    &gt; doubleNumber 4.0909
    8.1818</code></pre>
<p>Notice the new <code>=&gt;</code> symbol here. We first define all the typeclass instance variables we will be using (We separate each declaration with commas, although not shown here), put in the <code>=&gt;</code> symbol and then go on to define the function.</p>
<p>We will cover the functionality of type classes in a later chapter.</p>
<h2 data-number="10.5" id="functions-with-functions-as-arguments-revisited"><span class="header-section-number">10.5</span> Functions with Functions as Arguments Revisited</h2>
<p>Let us have a look at the type of <code>evalAddOne</code>, from Example 9.17:</p>
<pre><code>    &gt; :t evalAddOne
    evalAddOne :: Num a =&gt; (t -&gt; a) -&gt; t -&gt; a</code></pre>
<p>Let’s go through the function’s arguments one by one.</p>
<ol type="1">
<li><p><code>(t -&gt; a)</code>:</p>
<p>The function <em>takes in</em> a function expecting an argument and will finally return a number of some sort. We can deduce from the type definition of <code>evalAddOne</code> that this argument can be of any type that the function accepts (as indicated by the type variable <code>t</code>) but must return a number.</p>
<p>This function will therefore have the type definition: <code>Num a =&gt; (t -&gt; a)</code> Where the type variable <code>t</code> is dependent on the desired function.</p>
<p>In the test run we have done, we used the curried function <code>(*2)</code>. It has the following type defintition:</p>
<pre><code>&gt; :t (*2)
(*2) :: Num a =&gt; a -&gt; a
</code></pre>
<p>It therefore matches up with the conditions set by <code>evalAddOne</code>.</p>
<p>Thus, functions as arguments will appear like this in a type defintion.</p></li>
<li><p><code>t</code>:</p>
<p>The function then takes in an argument that will be received by the argument function, and thus should match up with the type requirement of the argument function, as deductible from the type variable <code>t</code>.</p></li>
<li><p><code>a</code>:</p>
<p>The function finally returns a number after all arguments have been consumed.</p></li>
</ol>
<h1 data-number="11" id="lists-part-2"><span class="header-section-number">11</span> Lists (Part 2)</h1>
<p>We will now go through a detailed description of lists and how they actually work.</p>
<h2 data-number="11.1" id="lists-in-haskell-are-not-arrays"><span class="header-section-number">11.1</span> “Lists” in Haskell are not Arrays</h2>
<p>Lists are internally represented as linked lists. This therefore has a number of implications on various operations on Lists, such that random access is an O(n) operation, appending is O(1), getting the last element is O(n) and so on. All operations will have the same complexity as operating on a linked list.</p>
<p>These data structures come from the tradition of the Lisp family of Languages, where the basic unit of structured data are <em>ordered pairs</em>. These ordered pairs can hold, as the name suggests, two pieces of data (of course, actual contiguous arrays and other structures exist, but this is the most standard method of structural organisation in Lisp).</p>
<p>The <code>cons</code> function in Lisp and its dialects creates such a pair. Here is an example in scheme, a Lisp dialect which illustrates this:</p>
<pre><code>    &gt; (cons 1 2)
    (1 . 2)

Here we bind the pair to a variable named &quot;a&quot;:

    &gt; (define a (cons 1 2))
    &gt; a
    (1 . 2)</code></pre>
<p>Just as a <em>linked list</em>, we chain these ordered pairs to store multiple pieces of data:</p>
<pre><code>    &gt; (define a (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 6))))))
    &gt; a
    (1 2 3 4 5 . 6)</code></pre>
<p>A visual representation of this structure would be as follows, which resembles a linked list. Each <code>.</code> refering to the container element:</p>
<pre><code>      .
     / \
    /   \
   1     .
        / \
       /   \
      2     .
           / \
          /   \
         3     .
              / \
             /   \
            4     .
                 / \
                /   \
               5     6</code></pre>
<p>There are functions that are analogous to Haskell’s <code>head</code> and <code>tail</code> called <code>car</code> (“current address register”), and <code>cdr</code> (“current decrement register”):</p>
<pre><code>    &gt; (car a)
    1
    &gt; (cdr a)
    (2 3 4 5 . 6)</code></pre>
<h2 data-number="11.2" id="cons-in-haskell"><span class="header-section-number">11.2</span> Cons in Haskell</h2>
<p>Haskell also has a <code>cons</code> equivalent, an infix operator: <code>:</code>. Although uptil now we have been using the other list notation for creating these pair chains.</p>
<p>In the example below, we use the cons operator to extend the list:</p>
<p><span id="example:11.1" class="pandoc-numbering-text example"><strong>Example 11.1</strong></span></p>
<pre><code>    &gt; k = [1, 2]
    &gt; m = 3:k
    &gt; m
    [3,1,2]</code></pre>
<p>We can also use this operator on an empty list. This allows us to construct a whole list from it.</p>
<p><span id="example:11.2" class="pandoc-numbering-text example"><strong>Example 11.2</strong></span></p>
<pre><code>    &gt; k = 1:2:3:4:5:[]
    &gt; k
    [1,2,3,4,5]</code></pre>
<p>The list notation is therefore simply syntactic sugar.</p>
<h2 data-number="11.3" id="using-cons-for-pattern-matching"><span class="header-section-number">11.3</span> Using Cons for Pattern Matching</h2>
<p>We can use the <code>:</code> operator to preemptively divide a list into its head and its tail by representing the current list as a <em>cons</em> between the head and the tail of the list, and thus making it visible as two separate variables within the function.</p>
<p>Here we will rewrite Example 5.1 in terms of this notation:</p>
<p><span id="example:11.3" class="pandoc-numbering-text example"><strong>Example 11.3</strong></span></p>
<pre><code>    &gt; :{
    .. sumNumbers [] = 0 -- Sum of an empty list of numbers is 0
    .. sumNumbers (x:xs) = x + sumNumbers xs -- x is the head, xs is the tail
    .. :}
    &gt; sumNumbers [2,4,6,8,10]
    30
</code></pre>
<p>There can be more than one elements in the cons pattern:</p>
<p><span id="example:11.4" class="pandoc-numbering-text example"><strong>Example 11.4</strong></span></p>
<pre><code>    &gt; sumFive (a:b:c:d:e:[]) = a + b + c + d + e
    &gt; sumFive [1,2,3,4,5]
    15
</code></pre>
<h2 data-number="11.4" id="list-ranges"><span class="header-section-number">11.4</span> List Ranges</h2>
<p>You can use the <code>..</code> operator within the list notation to define a list with a certain range of numbers.</p>
<p><span id="example:11.5" class="pandoc-numbering-text example"><strong>Example 11.5</strong></span></p>
<pre><code>We specify the starting and the ending numbers of the list.

    &gt; [1..10]
    [1,2,3,4,5,6,7,8,9,10]
    &gt; k = [1..10]
    &gt; k
    [1,2,3,4,5,6,7,8,9,10]</code></pre>
<p>As you can see, the list elements are included in increments of 1. Even for floating point numbers, this is the case:</p>
<p><span id="example:11.6" class="pandoc-numbering-text example"><strong>Example 11.6</strong></span></p>
<pre><code>    &gt; k = [1.15..10.20]
    &gt; k
    [1.15,2.15,3.15,4.15,5.15,6.15,7.15,8.15,9.15,10.15]</code></pre>
<p>Note how <code>10.20</code> is not in the list. You could say that this expression is equivalent to this for loop in a C-like language:</p>
<pre><code>for (int i = 1.15; i &lt;= 10.20; i += 1) {
    array.push(i)
} </code></pre>
<p>We can specify the second element of the list to specify a custom increment value:</p>
<p><span id="example:11.7" class="pandoc-numbering-text example"><strong>Example 11.7</strong></span></p>
<pre><code>    &gt; [2,4 .. 20]
    [2,4,6,8,10,12,14,16,18,20]</code></pre>
<p>We can also specify infinite lists. These may be useful in certain algorithms such as in the implementation of Eratosthenes’ Sieve and other places.</p>
<p><span id="example:11.8" class="pandoc-numbering-text example"><strong>Example 11.8</strong></span></p>
<pre><code>    &gt; k = [1..]
    &gt; k
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
    26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
    48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,
    70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
    92,93,94,95,96,97,98,99,100,101,102...
    
    (list does not stop printing unless interrupted by forcibly closing
    the program or sending an interrupt with a key combination like 
    CTRL + C)</code></pre>
<p>It is obvious to anyone that a computer will not be able to store an infinite list of numbers due to physical limitations of the computing device. Thus these numbers in ranges are generated only as it is required. This is true for non-infinite ranges as well.</p>
<h2 data-number="11.5" id="list-comprehensions"><span class="header-section-number">11.5</span> List Comprehensions</h2>
<p>List comprehensions are analogus to mathematical <em>set comprehensions</em>.</p>
<p>For example, the set of all odd numbers between 0 and 100 may be represented in Mathematical notation as follows:</p>
<p><em><strong>oddSet</strong> = { x | x ∈ ℕ, 1 ≤ x ≤ 100, x is odd }</em></p>
<p>This comprehension may be expressed in Haskell in a very similar manner:</p>
<p><span id="example:11.9" class="pandoc-numbering-text example"><strong>Example 11.9</strong></span></p>
<pre><code>Haskell has a very similar notation:

    &gt; oddSet = [ x | x &lt;- [1..100], x `mod` 2 /= 0 ]
    &gt; oddSet
    [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,
    49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,
    93,95,97,99]</code></pre>
<p>“<code>&lt;-</code>”, here is the “Element of” operator. “<code>/=</code>” is the “not equal to” operator.</p>
<p>Instead of <code>x</code>, we can write any function expression that uses <code>x</code> as a parameter. We can also use multiple variables in comprehansions:</p>
<p><span id="example:11.10" class="pandoc-numbering-text example"><strong>Example 11.10</strong></span></p>
<pre><code>    &gt; multiplicationTable = [(show(x)) ++ &quot; x &quot; ++ 
                             (show(y)) ++ &quot; = &quot; ++ (show(x*y))
                             | x &lt;- [2..10], y &lt;- [2..10] ]
    &gt; multiplicationTable
    [&quot;2 x 2 = 4&quot;,&quot;2 x 3 = 6&quot;,&quot;2 x 4 = 8&quot;,&quot;2 x 5 = 10&quot;,&quot;2 x 6 = 12&quot;,
    &quot;2 x 7 = 14&quot;,&quot;2 x 8 = 16&quot;,&quot;2 x 9 = 18&quot;,&quot;2 x 10 = 20&quot;,&quot;3 x 2 = 6&quot;,
    &quot;3 x 3 = 9&quot;,&quot;3 x 4 = 12&quot;,&quot;3 x 5 (...)</code></pre>
<p><em>Note that in order to split the list comprehension across multiple lines, the square bracket must be ended at the same or greater level of indentation as the rest of the block,</em></p>
<p>Here is a larger example. This program implements the popular “fizz-buzz” problem:</p>
<p><span id="example:11.11" class="pandoc-numbering-text example"><strong>Example 11.11</strong></span></p>
<pre><code>    &gt; fizzBuzz = [
    ..     if (x `mod` 3) == 0 &amp;&amp; (x `mod` 5) == 0 then &quot;FizzBuzz&quot;
    ..     else if (x `mod` 3) == 0 then &quot;Fizz&quot;
    ..     else &quot;Buzz&quot;
    ..     | x &lt;- [1..100],
    ..       ((x `mod` 3) == 0) || ((x `mod` 5) == 0) ]
    &gt; fizzBuzz
    [&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;FizzBuzz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,
    &quot;Fizz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;FizzBuzz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;Fizz&quot;,
    &quot;Buzz&quot;,&quot;Fizz&quot;,&quot;FizzBuzz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,
    &quot;FizzBuzz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;FizzBuzz&quot;,
    &quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;FizzBuzz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,
    &quot;Fizz&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;]</code></pre>
<p>We will learn a method to print all of these strings later.</p>
<h1 data-number="12" id="tuples"><span class="header-section-number">12</span> Tuples</h1>
<p>Tuples are arrays of elements that are immutable, and cannot be changed in size. These can be useful to store objects such as database rows, coordinates, vectors etc.</p>
<pre><code>    &gt; t = (1, 2)
    &gt; t
    (1,2)
    &gt; :t t
    t :: (Num a, Num b) =&gt; (a, b)</code></pre>
<p>As you can see, tuple types are represented using rounded brackets.</p>
<p>Here is an example of a list which stores tuples of fruit names and their prices:</p>
<p><span id="example:12.1" class="pandoc-numbering-text example"><strong>Example 12.1</strong></span></p>
<pre><code>    &gt; fruitList :: [([Char], Float)]; fruitList = [(&quot;apple&quot;, 12.3), 
    (&quot;banana&quot;, 4.2)]
    &gt; fruitList
    [(&quot;apple&quot;,12.3),(&quot;banana&quot;,4.2)]
 
Now, attempting to insert an illegal element:

    &gt; newList = (132, 123) : fruitList

    &lt;interactive&gt;:75:12: error:
        • No instance for (Num [Char]) arising from the literal ‘132’
        • In the expression: 132
          In the first argument of ‘(:)’, namely ‘(132, 123)’
          In the expression: (132, 123) : fruitList</code></pre>
<h2 data-number="12.1" id="fst-and-snd"><span class="header-section-number">12.1</span> <code>fst</code> and <code>snd</code></h2>
<p>Haskell by default includes functions for accessing the first and second elements of a 2 element tuple:</p>
<pre><code>    &gt; k = (4, 5)
    &gt; fst k
    4
    &gt; snd k
    5</code></pre>
<p>If we want more custom functions for accessing data from n-tuples, we can define them as follows. Since tuples contain fixed size, immutable, heterogenous data, there is no way to “traverse” them.</p>
<pre><code>    &gt; tuple3Fst (a, b, c) = a
    &gt; tuple3Snd (a, b, c) = b
    &gt; tuple3Thrd (a, b, c) = c
    &gt; tuple3Thrd (3, 4, 1)
    1</code></pre>
<h1 data-number="13" id="iteration-in-haskell"><span class="header-section-number">13</span> Iteration in Haskell</h1>
<p>We have several utility functions that act on lists. There are a lot of familliar functions that you will notice here if you have used languages such as Python.</p>
<h2 data-number="13.1" id="the-iterate-function"><span class="header-section-number">13.1</span> The <code>iterate</code> Function</h2>
<p><code>iterate</code> is similar to an infinite list comprehension, but one can use any desired iteration function to generate successive numbers in the list.</p>
<p><span id="example:13.1" class="pandoc-numbering-text example"><strong>Example 13.1</strong></span></p>
<pre><code>    &gt; q = (iterate (1+) 1)
    &gt; q
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,...
    
    &gt; q = (iterate (2*) 1)
    &gt; 
    &gt; q
    [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,
    65536,131072,...</code></pre>
<h2 data-number="13.2" id="the-map-function"><span class="header-section-number">13.2</span> The <code>map</code> function</h2>
<p>The <code>map</code> function applies a function to all the elements on a list.</p>
<p>In this example we increment all numbers present in a list:</p>
<p><span id="example:13.2" class="pandoc-numbering-text example"><strong>Example 13.2</strong></span></p>
<pre><code>    &gt; map (1+) [1,2,3,4,5]
    [2,3,4,5,6]
</code></pre>
<p>The map function can also be used to create new curried functions which then can be later applied:</p>
<p><span id="example:13.3" class="pandoc-numbering-text example"><strong>Example 13.3</strong></span></p>
<pre><code>    &gt; addCurryList = map (+) [1..20]
    &gt; (head addCurryList) 10
    11
</code></pre>
<h2 data-number="13.3" id="the-filter-function"><span class="header-section-number">13.3</span> The <code>filter</code> Function</h2>
<p>The filter function, as the name may suggest, filters things from a list. It takes a function that returns a truth value and operates it on each element of a list. If the function returns true for an element, then that element is accepted into the new list that <code>filter</code> will return.</p>
<p><span id="example:13.4" class="pandoc-numbering-text example"><strong>Example 13.4</strong></span></p>
<pre><code>This statement will get odd numbers between 1 and 20:

    &gt; filter (\x -&gt; (x `mod` 2) == 0) [1..20]
    [2,4,6,8,10,12,14,16,18,20]
</code></pre>
<p>Note how we were able to avoid assigning a new identifier to a function with the same functionality by using a lambda function instead.</p>
<h2 data-number="13.4" id="the-function-application-operator"><span class="header-section-number">13.4</span> The Function Application Operator (<code>$</code>)</h2>
<p>This operator takes in a function argument on the left hand side and an argument for the function argument on the right hand side, then evaluates the argument function and returns the result of the evaluation.</p>
<p>Let us have a look at the type of this function:</p>
<pre><code>    &gt; :t ($)
    ($) :: (a -&gt; b) -&gt; a -&gt; b</code></pre>
<p>You may see that this is more or less equivalent to the type definition of the function <code>evalAddOne</code> presented in Example 9.17 (and discussed further in section 10.5), only that no type classes are used here, thus making the function entirely generic.</p>
<p>Let us see an example usage of this:</p>
<p><span id="example:13.5" class="pandoc-numbering-text example"><strong>Example 13.5</strong></span></p>
<pre><code>    &gt; sqrt $ 16
    4.0
    &gt; ($) sqrt 16
    4.0</code></pre>
<p>This function comes in very handy when we attempt to use <code>map</code> on all the functions created in the list in example 13.2. It prevents us entirely from defining an explicit lambda function to evaluate it.</p>
<p><span id="example:13.6" class="pandoc-numbering-text example"><strong>Example 13.6</strong></span></p>
<pre><code>Evaluating list without the $ operator:

    &gt; map (\func -&gt; func 100) addCurryList
    [101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
    117,118,119,120]

Now evaluating the list with the $ operator:

    &gt; map ($ 100) addCurryList
    [101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
    117,118,119,120]</code></pre>
<p>We can also use it to evaluate a function on a list of operands by putting the function on the left hand side:</p>
<p><span id="example:13.7" class="pandoc-numbering-text example"><strong>Example 13.7</strong></span></p>
<pre><code>    &gt; map (sqrt $) [1..20]
    [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,
    2.449489742783178,2.6457513110645907,2.8284271247461903,3.0,
    3.1622776601683795,3.3166247903554,3.4641016151377544,
    3.605551275463989,3.7416573867739413,3.872983346207417,4.0,
    4.123105625617661,4.242640687119285,4.358898943540674,
    4.47213595499958]
</code></pre>
<h2 data-number="13.5" id="the-zip-function"><span class="header-section-number">13.5</span> The <code>zip</code> Function</h2>
<p>This function takes two lists, and combines each pair of their elements them into tuples in successive order:</p>
<p><span id="example:13.8" class="pandoc-numbering-text example"><strong>Example 13.8</strong></span></p>
<pre><code>    &gt; zip [1, 2, 3] [4, 5, 6]
    [(1,4),(2,5),(3,6)]
    
    &gt; zip [1, 2] [1, 2, 3, 4]
    [(1,1),(2,2)]</code></pre>
<h2 data-number="13.6" id="the-zipwith-function"><span class="header-section-number">13.6</span> The <code>zipWith</code> Function</h2>
<p>This function takes two lists, and a function that will operate on each successive pair of elements, and generate a new list from all the values returned from this function:</p>
<p><span id="example:13.9" class="pandoc-numbering-text example"><strong>Example 13.9</strong></span></p>
<pre><code>    &gt; zipWith (/) [1, 2, 3] [4, 5, 6]
    [0.25,0.4,0.5]
</code></pre>
<h2 data-number="13.7" id="the-fold-and-scan-functions"><span class="header-section-number">13.7</span> The <code>fold</code> and <code>scan</code> Functions</h2>
<p>The <code>fold</code> functions are what you use to update the state or keep “persistent variables” while performing iteration. Essentially, this is your <code>for</code> loop in Haskell.</p>
<h3 data-number="13.7.1" id="foldl-fold-from-left-to-right"><span class="header-section-number">13.7.1</span> <code>foldl</code>: Fold from Left to Right</h3>
<p><code>foldl</code> has the following arguments:</p>
<pre><code>    foldl func accumulator list
</code></pre>
<p>The argument <code>func</code> has the following arguments:</p>
<pre><code>    func accumulator currentVariable
</code></pre>
<ul>
<li><code>accumulator</code> is the persistent variable. It has the initial value <code>initialValue</code>.</li>
<li><code>currentVariable</code> is the current list element we are on.</li>
<li>It will return the new value of the accumulator</li>
</ul>
<p><code>foldl</code> recursively operates in the following manner:</p>
<pre><code>foldl func accumulator [] = accumulator
foldl func accumulator list = foldl func (func accumulator (head list))
                              (tail list)</code></pre>
<ul>
<li><p>If the list is empty, the accumulator value will be the initial value. This is the base case.</p></li>
<li><p>Else, the new accumulator value will be the return value of func. We will supply it with the initial accumulator value, and the current index value of the list.</p></li>
</ul>
<p>Thus, we are operating the list in a “folding” manner.</p>
<p>Let us have a look at an example. This expression generates a number with the elements as the digits in the list:</p>
<p><span id="example:13.10" class="pandoc-numbering-text example"><strong>Example 13.10</strong></span></p>
<pre><code>    &gt; foldl (\x y -&gt; x*10 + y) 5 [4, 3, 2, 1]
    54321</code></pre>
<p>The traceback of this function will be as follows;</p>
<pre><code>1. foldl func 5     [4, 3, 2, 1]
2. foldl func 54    [3, 2, 1]
3. foldl func 543   [2, 1]
4. foldl func 5432  [1]
5, foldl func 54321 []
6. 54321</code></pre>
<h3 data-number="13.7.2" id="foldr-fold-from-right-to-left"><span class="header-section-number">13.7.2</span> <code>foldr</code>, Fold from Right to Left</h3>
<p><code>foldr</code> is implemented like so:</p>
<pre><code>    &gt; :{
    ..     foldr func i [] = i
    ..     foldr func i (x:xs) = func x (foldr func i xs)
    .. :}</code></pre>
<p>This time, as you might be able to notice, the current variable and accumulator variables are swapped.</p>
<pre><code>    func currentVariable accumulator</code></pre>
<p>The rationale for such an arrangement comes from the fact that we are “folding” the list leftwards, and the “folds” “accumulate” on the right or the left side of the list. Thus allowing for a mnemonic representation of the accumulation.</p>
<p><span id="example:13.11" class="pandoc-numbering-text example"><strong>Example 13.11</strong></span></p>
<pre><code>    &gt; foldr (-) 5 [1, 2, 3, 4]
    3</code></pre>
<p>If we were to expand this whole operation into a single expression. It would look like this:</p>
<pre><code>(5 - (4 - (3 - (2 - 1))))
</code></pre>
<h3 data-number="13.7.3" id="scanl-and-scanr"><span class="header-section-number">13.7.3</span> <code>scanl</code> and <code>scanr</code></h3>
<p>These two functions are same as the <code>fold</code> functions, but instead of simply returning the final accumulator value at the end, the whole list of each successive accumulator values are returned.</p>
<p><span id="example:13.12" class="pandoc-numbering-text example"><strong>Example 13.12</strong></span></p>
<pre><code>    &gt; scanl (\x y -&gt; x*10 + y) 5 [4, 3, 2, 1]
    [5,54,543,5432,54321]
    &gt;  scanr (-) 5 [1, 2, 3, 4]
    [3,-2,4,-1,5]</code></pre>
<h3 data-number="13.7.4" id="note-pattern-matching-in-these-functions"><span class="header-section-number">13.7.4</span> Note: Pattern Matching in these Functions</h3>
<p>One can simply set the initial accumulator value and then update it through the updation function. This allows us to update multiple values in each iteration step.</p>
<p>Here is an example of how we would write a function that would calculate the average of a series of numbers:</p>
<p><span id="example:13.13" class="pandoc-numbering-text example"><strong>Example 13.13</strong></span></p>
<pre><code>    &gt; :{
    .. average l = (fst k) / (snd k)
    ..     where k = foldl (\(s, c) y -&gt; (s + y, c + 1)) (0, 0) l
    .. :}
    &gt; average [1, 2, 3, 4, 5]
    3.0</code></pre>
<h3 data-number="13.7.5" id="foldl1-foldr1-scanl1-and-scanr1"><span class="header-section-number">13.7.5</span> <code>foldl1</code>, <code>foldr1</code>, <code>scanl1</code> and <code>scanr1</code></h3>
<p>These functions suffixed with 1 do not require the initial accumulator variable as an argument. The accumulator variable is therefore of the type of the initial variable of the list:</p>
<p><span id="example:13.14" class="pandoc-numbering-text example"><strong>Example 13.14</strong></span></p>
<pre><code>    &gt; foldl1 (\x y -&gt; x + y) [1, 2, 3, 4, 5]
    15
</code></pre>
<h1 data-number="14" id="data-records-types-and-typeclasses"><span class="header-section-number">14</span> Data, Records, Types, and Typeclasses</h1>
<h2 data-number="14.1" id="data"><span class="header-section-number">14.1</span> Data</h2>
<p>“<code>data</code>” definitions are a method of making a new set of symbols that act as values for variables. These are quite similar to enumerations.</p>
<p>In this example we define a data type enumerating the several stages of human life and make a variable with that data type:</p>
<p><span id="example:14.1" class="pandoc-numbering-text example"><strong>Example 14.1</strong></span></p>
<pre><code>    &gt; :{
    ..     data HumanStage = Baby | Toddler | Kid
    ..         | Teenager | YoungAdult | MiddleAgedAdult | Old | Senile 
    .. :}
    &gt; a = Senile
    &gt; :t a
    a :: HumanStage
</code></pre>
<h3 data-number="14.1.1" id="printing-new-data-types"><span class="header-section-number">14.1.1</span> Printing New Data Types</h3>
<p>On attempting to simply pass the variable to the interpreter, which as we have seen before simply evaluates the expression and attempts to print it we get the following error:</p>
<pre><code>    &gt; a

    &lt;interactive&gt;:11:1: error:
        • No instance for (Show HumanStage) arising from a use of ‘print’
        • In a stmt of an interactive GHCi command: print it
</code></pre>
<p>This is because of how GHCI attempts to print the datatype after the successful evaluation. It invokes the <code>print</code> function which in turn invokes <code>show</code> to convert it into a string.</p>
<p>In order to tell Haskell to use a verbatim string representation of the data type symbols, we have to make it derive from the <code>Show</code> typeclass:</p>
<p><span id="example:14.2" class="pandoc-numbering-text example"><strong>Example 14.2</strong></span></p>
<pre><code>    &gt; :{
    .. data HumanStage =
    ..     Baby | Toddler | Kid | Teenager | YoungAdult |   
    ..     MiddleAgedAdult | Old | Senile
    ..     deriving (Show)
    .. :}
    &gt; print Baby
    Baby
    &gt; a = Teenager
    &gt; print a
    Teenager
    &gt; putStrLn $ (show Teenager) ++ &quot; &quot; ++ (show Baby)
    Teenager Baby</code></pre>
<h3 data-number="14.1.2" id="tuple-like-data"><span class="header-section-number">14.1.2</span> Tuple-Like Data</h3>
<p>We can add parameters to each of our symbols in our data types to make them hold data.</p>
<p><span id="example:14.3" class="pandoc-numbering-text example"><strong>Example 14.3</strong></span></p>
<pre><code>    &gt; :{
    .. data Coordinates = 
    ..     TwoDim Float Float |
    ..     ThreeDim Float Float Float
    .. :}
    &gt; (TwoDim 4 5)
    TwoDim 4.0 5.0
    &gt; (ThreeDim 4 5 6)
    ThreeDim 4.0 5.0 6.0 
    &gt; a = (TwoDim 6 7)
    &gt; a
    (TwoDim 6.0 7.0)</code></pre>
<p><code>TwoDim</code> and <code>ThreeDim</code> here are called Data Constructors.</p>
<p>We can pattern match such tuples in functions like this:</p>
<pre><code>    &gt; twoDimSquare (TwoDim a b) = (TwoDim (a * 2) (b * 2))
    &gt; twoDimSquare (TwoDim 4 5)
    TwoDim 8.0 10.0</code></pre>
<p>In fact, these data constructors are functions and can be used as such. The bottom value of the function will be the data “tuple”.</p>
<h3 data-number="14.1.3" id="type-variables-in-data-constructors"><span class="header-section-number">14.1.3</span> Type Variables in Data Constructors</h3>
<p>We can add arguments beside our data type identifier to add in type variables, hence allow us to generalise the data type:</p>
<p><span id="example:14.4" class="pandoc-numbering-text example"><strong>Example 14.4</strong></span></p>
<pre><code>    &gt; data WeightedValue a = IntWeightedValue a Int | FloatWeightedValue a Float deriving (Show)
    &gt; q :: WeightedValue [Char]; q = (IntWeightedValue &quot;Apple&quot; 5)
    &gt; q
    IntWeightedValue &quot;Apple&quot; 5</code></pre>
<h3 data-number="14.1.4" id="recursive-data-constructors"><span class="header-section-number">14.1.4</span> Recursive Data Constructors</h3>
<p>You can define recursive types, much like the way one would use self referrential struct pointers in C/C++. This allows you to define data structures like trees:</p>
<p><span id="example:14.5" class="pandoc-numbering-text example"><strong>Example 14.5</strong></span></p>
<pre><code>    &gt; :{
    .. data TreeNode = 
    ..       Node Integer TreeNode TreeNode 
    ..     | BottomNode deriving (Show)
    .. treeleft (Node v l r) = l
    .. treeright (Node v l r) = r
    .. treeval (Node v l r) = v
    .. :}
    &gt; a = (Node 1 
    ..         (BottomNode) 
    ..         (Node 3 
    ..             (Node 4 
    ..                 (BottomNode) 
    ..                 (BottomNode)) 
    ..             (BottomNode)))
    &gt; a
    Node 1 BottomNode (Node 3 (Node 4 BottomNode BottomNode) BottomNode)
    &gt; treeright a
    Node 3 (Node 4 BottomNode BottomNode) BottomNode
    &gt; treeleft $ treeright $ a
    Node 4 BottomNode BottomNode
    &gt; treeval $ treeleft $ treeright $ a
    4</code></pre>
<h3 data-number="14.1.5" id="records"><span class="header-section-number">14.1.5</span> Records</h3>
<p>Records are like the previously mentioned Tuple-Like Data Types, except each member of the tuple has an explicit identifier. Quite a lot like a struct in C or class member access in object oriented languages.</p>
<p>Here we reimplement our previous tree definition using records:</p>
<p><span id="example:14.6" class="pandoc-numbering-text example"><strong>Example 14.6</strong></span></p>
<pre><code>data Tree a = 
      Node {
          value :: a,
          left  :: Tree a,
          right :: Tree a
      }
    | BottomNode;
</code></pre>
<p>We can define a variable record as follows:</p>
<pre><code>    &gt; a :: Tree Int; a = Node {value = 5, left = BottomNode, right = BottomNode}</code></pre>
<p>We can pattern-match records in functions as follows:</p>
<pre><code>    &gt; treeleft (Node {value = v, left = l, right = r}) = l
    &gt; treeleft a
    BottomNode</code></pre>
<p>It is not necessary that we match all the variables all the time for a function. Matching only those which we require in the function is enough:</p>
<pre><code>    &gt; treeleft (Node {left = l}) = l
    &gt; treeleft a
    BottomNode</code></pre>
<hr />
</body>
</html>
